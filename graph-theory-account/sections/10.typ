= Веса IV с
== Условие
N-периферией для вершины называется множество вершин, расстояние от которых до заданной вершины больше N. Определить N-периферию для заданной вершины графа.

== Код (фрагменты кода)
```
void Graph::floydPeriphery(const string& start, int N) const {
    int n = adjList.size();
    if (n == 0) {
        cout << "Граф пуст.\n";
        return;
    }

    // Сопоставляем вершины индексам
    unordered_map<string, int> idx;
    for (int i = 0; i < n; ++i)
        idx[adjList[i].adress] = i;

    if (!idx.count(start)) {
        cout << "Вершина " << start << " не найдена в графе.\n";
        return;
    }

    // Инициализация матрицы расстояний
    vector<vector<int>> dist(n, vector<int>(n, INT_MAX / 2));

    for (int i = 0; i < n; ++i)
        dist[i][i] = 0;

    for (int i = 0; i < n; ++i)
        for (const auto& e : adjList[i].adj)
            dist[i][idx[e.to]] = min(dist[i][idx[e.to]], e.weight);

    // Алгоритм Флойда–Уоршелла
    for (int k = 0; k < n; ++k)
        for (int i = 0; i < n; ++i)
            for (int j = 0; j < n; ++j)
                if (dist[i][j] > dist[i][k] + dist[k][j])
                    dist[i][j] = dist[i][k] + dist[k][j];

    // Определяем N-периферию
    int s = idx[start];
    vector<string> periphery;
    for (int i = 0; i < n; ++i)
        if (dist[s][i] > N && dist[s][i] < INT_MAX / 2)
            periphery.push_back(adjList[i].adress);

    // Вывод результата
    cout << "N-периферия вершины " << start << " (N = " << N << "): ";
    if (periphery.empty())
        cout << "пусто\n";
    else {
        for (const auto& v : periphery)
            cout << v << " ";
        cout << "\n";
    }
}
```

== Краткое описание алгоритма
Этот алгоритм находит N-периферию вершины с использованием алгоритма Флойда-Уоршелла.
=== Что делает
Находит все вершины, расстояние до которых от стартовой вершины превышает заданное значение N.

Шаги алгоритма:
1. Подготовка данных

Создает словарь для сопоставления имен вершин с индексами

Проверяет существование стартовой вершины

2. Инициализация матрицы расстояний

Заполняет матрицу большими значениями (INT_MAX / 2)

Диагональ (расстояние до себя) = 0

Заполняет прямые связи из списка смежности

3. Алгоритм Флойда-Уоршелла

Тройной цикл для нахождения кратчайших путей между всеми парами вершин

Для каждой тройки (i, j, k) проверяет:
dist[i][j] > dist[i][k] + dist[k][j]

Если да - улучшает расстояние

4. Поиск N-периферии

Для стартовой вершины s находит все вершины i, где:
dist[s][i] > N и dist[s][i] < INF

Добавляет их в результат.

== Примеры входных и выходных данных
=== Входные данные
```
A B 2
A C 5
B C 1
B D 4
C E 3
D E 2
E F 6
B A -1
```

=== Выходные данные
```
Введите вершину: A
Введите N: 6
N-периферия вершины A (N = 6): F 
```